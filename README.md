# 数据结构学习
记录学习数据结构过程中的一些问题、感悟。  
注：该记录处于基础阶段，对本阶段所敲下的代码暂不考虑优化。（2021/7/27 1:02）  
## 线性表  
在创建线性表的时候，注意相关结构体的实现。  
### 顺序表示
顺序表需要保持元素在逻辑结构和物理结构上的一致，常常用数组实现。但定义数组需要明确定义长度，这样的限制条件在用数组创建顺序表带来了诸多不便。因此采用了malloc()、free()函数以及使用指针的方式，动态开辟物理地址上连续的内存空间，实现顺序表创建。（这样美妙的搭配形式参考《C Primer Plus (第六版)》中对malloc()、free()、typedef struct的解释，对为何使用这样的方式有更好的理解）  
#### ·对于顺序表的相关操作  
主要关注点放在插入和删除的实现。  
思想：插后动，删前移。设i为要进行修改的元素的位置。  
·插入过程，从下标为n-1到i的元素均向后移动一个位置；将元素插入到顺序表第i个位置；修改表示顺序表中存放个数的变量。  
·删除过程，从下标为i开始到n-1的元素均向前移动一个位置；修改表示顺序表中存放个数的变量。  
### 链式表示
链式表示只关心逻辑而不关心物理结构，元素均由结点表示。结点包含数据域以及指针域。（这里均使用带头结点的链表）  
###  单链表  
结点中只包含数据域以及一个指针域。（指针域指向后继结点的存储位置）  
#### 对单链表的相关操作  
在进行插入以及删除过程中，都需要找点前驱结点才能实现。  
### 双链表  
每个结点包含数据域以及两个指针域。（分别指向前驱结点、后继结点的存储位置）  
双链表表示优化了在单链表中执行操作的麻烦，不依赖前驱结点。
### Josephus问题  
描述：设有n个人围成一圈，从第s个人开始报数，数到第m的人出列，然后出列的下一个人重新开始报数，数到第m的人出列，以此规律重复到所有人都出列。求按照该出列次序得到的序列。这是一个线性表上多次删除的问题。（解决这个问题，我使用了循环双链表）  
#### 问题核心：  
如何完成出列，即删除结点的规律。  
#### 核心思路：  
·循环①（找结点）：使用一个条件为m，找出第m个位置出列的结点，保存该结点的后继结点。  
·循环②（多次删除）：删除本结点，在循环②中嵌套循环①。  
·在循环②过程中保存每个出列的结点数据域。
